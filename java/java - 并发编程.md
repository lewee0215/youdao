# Java 并发编程中的三个概念
https://www.hollischuang.com/archives/2550  
1. 原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行
> 只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作

Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现

2. 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值

3. 有序性：即程序执行的顺序按照代码的先后顺序执行
在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性

## synchronized 实现可见性
Java中synchronized关键字有两重含义，一是大家所熟知的实现原子性，二就是实现内存可见性。
1. 线程解锁前必须把共享变量的最新值刷新到主内存中
2. 线程加锁时，将清空工作内存中共享变量的值，从而需要从主内存中重新读取最新值

## volatile 实现可见性
Java中的volatile可以保证volatile变量的可见性，但不保证复合操作的原子性(如++)
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值

1. 对volatile变量执行写操作时，会在写操作后加入一条store写屏障指令，强制将缓存刷新到主内存中
2. 对volatile变量执行读操作时，会在读操作前加入一条load读屏障指令，强制使缓冲区缓存失效，所以会从主内存读取最新值。
3. 防止指令重排序